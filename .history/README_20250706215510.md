# 🛍️ Odento-SHOP

Bienvenue dans **Odento-SHOP**, un site e-commerce de démonstration développé avec **Symfony 6.4**, **EasyAdmin**, **Doctrine**, **Bootstrap** et **MySQL**.  
Le projet a été créé dans le cadre d’un apprentissage guidé avec accompagnement pédagogique.

---

## 🔧 Technologies principales

- Symfony 6.4 (LTS)
- PHP 8.2
- EasyAdmin
- Doctrine ORM
- Bootstrap 5
- MySQL (via XAMPP)
- Git / GitHub

---

## 📊 Fonctionnalités réalisées

✅ Gestion des produits (Articles)  
✅ Gestion des catégories (avec relation ManyToOne → Article)  
✅ Gestion des posts (blog)  
✅ **Upload d’images dans les posts via EasyAdmin**  
✅ **Refonte visuelle des formulaires Login et Register avec Bootstrap 5 via YAML**  
✅ Gestion des utilisateurs avec sécurité (User + authentification)  
✅ Dashboard complet avec EasyAdmin  
✅ Migrations Doctrine  
✅ Architecture MVC claire
✅ Gestion des utilisateurs avec sécurité (User + authentification)
✅ Dashboard complet avec EasyAdmin
✅ Migrations Doctrine
✅ Architecture MVC claire
✅ **Formulaire de contact avec validation et feedback utilisateur (erreurs/succès)**
---

## 🖼️ Upload d’image dans les Posts

- Champ `image` ajouté dans l’entité `Post`
- Dashboard EasyAdmin avec **champ image upload automatique**
- Stockage dans `public/images/`
- Nom du fichier géré automatiquement
- Image visible dans l’administration

---

## 🎨 Refonte des formulaires Login & Register

- Les formulaires `login.html.twig` et `register.html.twig` utilisent désormais une structure **Bootstrap 5 complète**
- Utilisation de `container`, `card`, `form-control`, `row`, `col`, etc.
- Intégration cohérente avec le thème du site
- **Meilleure expérience utilisateur** (visuelle + responsive)

---

## 🛠️ Installation du projet

### 1. Cloner le dépôt Git

```bash
git clone https://github.com/rigal34/odento.git
cd odento
```

### 2. Installer les dépendances PHP

```bash
composer install
```

### 3. Configuration de la base de données

Dans le fichier `.env` :

```env
DATABASE_URL="mysql://root:@127.0.0.1:3306/odento"
```

Créer la base et les tables :

```bash
php bin/console doctrine:database:create
php bin/console doctrine:migrations:migrate
```

### 4. Lancer le serveur Symfony

```bash
symfony serve -d
```

Ou avec PHP directement :

```bash
php -S localhost:8000 -t public
```

### 5. Accéder à l’administration

- http://localhost:8000/admin  
- Connectez-vous avec un utilisateur existant ou créez-en un

---

## 📂 Structure du Projet Odento-SHOP

odento/
├── assets/                  # Fichiers sources (JS, CSS, images) avant compilation
│   ├── styles/
│   │   ├── app.css          # Fichier CSS principal (ton code CSS custom, si tu en as)
│   │   └── main.css         # Le CSS principal de ton thème Bootstrap (importé dans app.css)
│   ├── javascript/          # Nouveau dossier pour mieux organiser le JS
│   │   ├── app.js           # Fichier JavaScript principal (ton code JS custom, importations)
│   │   └── main.js          # Le JS principal de ton thème Bootstrap (si séparé de app.js)
│   ├── img/                 # Dossier pour les images du thème et statiques
│   │   ├── favicon.png
│   │   ├── product/
│   │   │   └── ...          # Images de produits, etc.
│   │   └── vendor/          # Si le thème a des images spécifiques à ses vendors (ex: icônes)
│   └── vendor/              # Fichiers CSS/JS des bibliothèques externes de ton thème (Bootstrap, Swiper, etc.)
│       ├── bootstrap/
│       ├── bootstrap-icons/
│       ├── swiper/
│       └── ...
│
├── config/                  # Cœur de la configuration de Symfony
│   ├── packages/
│   │   ├── security.yaml    # Gestion de la sécurité, des rôles, du pare-feu
│   │   ├── twig.yaml        # Configuration de Twig (ex: thème pour les formulaires)
│   │   └── webpack_encore.yaml # Configuration de Webpack Encore pour la compilation des assets
│   ├── routes/              # Optionnel, si tu externalises tes routes (sinon, direct dans les contrôleurs)
│   │   └── ...
│   └── services.yaml        # Configuration de tes services personnalisés
│
├── migrations/              # Fichiers de migration pour la base de données (générés)
│   └── Version2025...php    # Chaque fichier représente une modification du schéma de la BDD
│
├── public/                  # Racine web, seul dossier accessible par les navigateurs
│   ├── build/               # Dossier généré par Webpack Encore (contient les assets compilés)
│   │   ├── app.css
│   │   ├── app.js
│   │   ├── images/          # Images copiées par Encore
│   │   └── ...
│   ├── images/              # Dossier pour les images uploadées (produits, posts, etc.)
│   └── index.php            # Point d'entrée unique de toute l'application
│
├── src/                     # Le cœur de ton code PHP
│   ├── Controller/
│   │   ├── Admin/
│   │   │   └── ...CrudController.php # Tous les contrôleurs pour le dashboard EasyAdmin
│   │   ├── CartController.php       # Logique du panier : ajout, suppression, affichage
│   │   ├── CategorieController.php  # Affichage des produits par catégorie
│   │   ├── CheckoutController.php   # Processus de commande de A à Z
│   │   ├── ContactController.php    # Gère le formulaire de contact et l'envoi d'email
│   │   ├── FaqController.php        # <--- TON NOUVEAU CONTRÔLEUR FAQ
│   │   ├── PaymentMethodsController.php # <--- TON NOUVEAU CONTRÔLEUR MÉTHODES DE PAIEMENT
│   │   ├── PrivacyPolicyController.php # <--- TON NOUVEAU CONTRÔLEUR POLITIQUE DE CONFIDENTIALITÉ
│   │   ├── PostController.php       # Gère l'affichage des articles (blog) et des commentaires
│   │   └── SecurityController.php   # Gère la connexion et l'inscription des utilisateurs
│   │
│   ├── Entity/
│   │   ├── Article.php              # Entité pour les produits de la boutique
│   │   ├── Category.php             # Entité pour les catégories (avec auto-référence)
│   │   ├── Comment.php              # Entité pour les commentaires des posts
│   │   ├── Order.php                # Entité pour les commandes globales
│   │   ├── OrderItem.php            # Entité pour les lignes d'une commande
│   │   ├── Post.php                 # Entité pour les articles du blog
│   │   └── User.php                 # Entité pour les utilisateurs
│   │
│   ├── Form/
│   │   ├── CheckoutType.php         # Formulaire pour les informations de livraison
│   │   ├── CommentFormType.php      # Formulaire pour soumettre un commentaire
│   │   ├── ContactFormType.php      # Formulaire pour la page de contact
│   │   └── RegisterType.php         # Formulaire d'inscription
│   │
│   ├── Repository/                  # Classes spécialisées pour les requêtes en BDD
│   │   ├── ArticleRepository.php
│   │   ├── CategoryRepository.php
│   │   └── ... (un repository par entité)
│   │
│   └── Service/                     # Classes pour la logique métier réutilisable
│       ├── CartService.php          # Centralise toute la logique du panier
│       └── MailService.php          # Service pour préparer et envoyer des emails
│
├── templates/               # Tous les fichiers de vue (HTML + Twig)
│   ├── admin/                 # Templates pour le back-office (si surchargés)
│   ├── cart/
│   │   ├── panier.html.twig   # Page d'affichage du panier complet
│   │   └── _cart_icon.html.twig # Partiel pour l'icône de panier dans la navbar
│   ├── checkout/
│   │   ├── checkout.html.twig   # Page de saisie des infos de commande
│   │   └── confirmation.html.twig # Page de remerciement après commande
│   ├── foire_aux_questions/   # <--- TON NOUVEAU DOSSIER POUR LA FAQ
│   │   └── index.html.twig    # Le fichier Twig de ta FAQ
│   ├── home/
│   │   ├── categorie.html.twig  # Page d'affichage des produits d'une catégorie
│   │   └── detail_produit.html.twig # Page de détail d'un produit
│   ├── legal/                 # <--- NOUVEAU DOSSIER POUR LES PAGES LÉGALES
│   │   ├── privacy_policy.html.twig # <--- TON FICHIER TWIG DE POLITIQUE DE CONFIDENTIALITÉ
│   │   └── terms_of_service.html.twig # Ton fichier Twig pour les CGV (si tu en as un)
│   ├── payment_methods/       # <--- NOUVEAU DOSSIER POUR LES PAGES DE MÉTHODES DE PAIEMENT
│   │   └── index.html.twig    # Le fichier Twig de tes méthodes de paiement
│   ├── partials/              # Dossier pour les morceaux de template réutilisables (header, footer, etc.)
│   │   ├── _header.html.twig
│   │   └── _footer.html.twig
│   ├── post/
│   │   ├── detail.html.twig   # Page de détail d'un article de blog
│   │   └── postindex.html.twig  # Page listant tous les articles de blog
│   └── base.html.twig         # Le template principal de tout le site
│
├── tests/                   # Dossier pour les tests automatiques
│
├── .env                     # Fichier de configuration des variables d'environnement
├── README.md                # Fichier Readme du projet
└── webpack.config.js   

Mise en place des règles d'accès pour les différentes sections du site.

* **Protection de la Section Administration :**
    * Le fichier `config/packages/security.yaml` a été modifié pour inclure une règle `access_control`.
    * Toutes les URLs commençant par `/admin` nécessitent maintenant que l'utilisateur authentifié possède le rôle `ROLE_ADMIN`.
    * Les utilisateurs non authentifiés sont redirigés vers la page de connexion.
    * Les utilisateurs authentifiés sans `ROLE_ADMIN` reçoivent une page "Accès Interdit" (erreur 403).
* **Création d'un Compte Administrateur :**
    * Pour l'instant, le premier compte administrateur est configuré en modifiant manuellement la colonne `roles` d'un utilisateur existant dans la base de données (table `user`) pour y ajouter `ROLE_ADMIN` (ex: `["ROLE_USER", "ROLE_ADMIN"]`).

---
Projet conçu à des fins pédagogiques avec aide d’un professeur.  
Toutes les entités, relations, migrations, et la configuration EasyAdmin ont été construites progressivement.  
Les formulaires front ont été retravaillés à la main avec Bootstrap pour un meilleur rendu utilisateur.

---

## 🔗 Liens utiles

- [Documentation Symfony](https://symfony.com/doc/current/index.html)
- [Documentation EasyAdmin](https://symfony.com/bundles/EasyAdminBundle/current/)
---

## 🗂️ Mise en page front-end - Page catégorie Twig

La page `categorie.html.twig` a été construite à partir d’un template Bootstrap avancé. Elle comprend :

- Un **système de filtres latéraux** : par catégories, prix, marques, couleurs
- Un **système d’affichage produit** (grid/list) avec images, prix, rating, boutons d’action
- Une section de pagination
- Une compatibilité responsive intégrée
- Une intégration Twig progressive pour relier dynamiquement les données back-end

🎯 Objectif de cette page :  
Afficher **les articles liés à une catégorie**, récupérés dynamiquement depuis la base de données Symfony, tout en conservant le design du template.

🛠️ Prochaine étape : insérer la boucle `{% for article in articles %}` dans la section "product-box" pour afficher chaque article dynamique avec son image, titre et prix.

---
🧭 Affichage dynamique des catégories et sous-catégories
Une nouvelle fonctionnalité a été ajoutée sur le front pour afficher les catégories principales et leurs sous-catégories de manière automatisée via Twig et Doctrine.

✅ Fonctionnalités ajoutées
Boucle {% for category in categories %} sur la page categorie.html.twig

Affichage dynamique de chaque catégorie récupérée depuis la base de données

Génération automatique des sous-catégories via une relation OneToMany auto-référencée

Utilisation de {{ category.id }} pour gérer les collapse Bootstrap (affichage/masquage)

Les sous-catégories sont affichées via la boucle :

twig
Copier
Modifier
{% for Subcategory in category.categories %}
  {{ Subcategory.name }}
{% endfor %}
📦 Exemple HTML rendu (extrait) :
html
Copier
Modifier
<li class="category-item">
  <div class="category-header" data-bs-toggle="collapse" data-bs-target="#subcat-1">
    <a href="javascript:void(0)" class="category-link">Vêtements</a>
  </div>
  <ul id="subcat-1" class="subcategory-list collapse">
    <li class="subcategory-item"><a href="#">Hommes</a></li>
    <li class="subcategory-item"><a href="#">Femmes</a></li>
  </ul>
</li>
🛠️ Code utilisé dans categorie.html.twig :
twig
Copier
Modifier
<ul class="category-tree list-unstyled mb-0">
  {% for category in categories %}
    <li class="category-item">
      <div class="category-header collapsed"
           data-bs-toggle="collapse"
           data-bs-target="#categories-1-clothing-subcategories-{{ category.id }}"
           aria-expanded="false"
           aria-controls="categories-1-clothing-subcategories-{{ category.id }}">
        <a href="javascript:void(0)" class="category-link">{{ category.name }}</a>
      </div>

      <ul id="categories-1-clothing-subcategories-{{ category.id }}" class="subcategory-list collapse">
        {% for Subcategory in category.categories %}
          <li><a href="javascript:void(0)" class="subcategory-link">{{ Subcategory.name }}</a></li>
        {% endfor %}
      </ul>
    </li>
  {% endfor %}
</ul>
🔄 Objectif de cette fonctionnalité :
Permettre au client ou à l’administrateur de modifier les catégories ou sous-catégories depuis le dashboard EasyAdmin,
et de voir ces changements automatiquement reflétés sur le site, sans modifier le code HTML.
---

## ✨ Améliorations et Corrections Récentes (Session du 2 Mai - Montpellier)

Cette section documente les ajustements et intégrations réalisés lors de notre session de travail et de mentorat.

### 1. Correction Affichage Images Articles

* **Problème Identifié :** Les images des articles (liées via `article.image`) ne s'affichaient pas de manière cohérente. Elles apparaissaient sur la page catégorie (`/categorie?id=X`) mais pas sur la page détail produit (`/produit/X`).
* **Cause :** Utilisation d'un chemin relatif (`src="images/{{ article.image }}"`) dans les templates Twig. Le navigateur interprétait ce chemin différemment en fonction de l'URL de la page courante, échouant sur les pages avec une structure d'URL plus "profonde" (comme `/produit/X`).
* **Solution Implémentée :** Remplacement systématique des chemins relatifs par la fonction Twig `asset()` pour générer des URLs publiques fiables depuis la racine web (`public/`). Le code utilise maintenant `src="{{ asset('images/' ~ article.image) }}"` (en supposant que les images sont dans `public/images/`) dans `detail_produit.html.twig` et `categorie.html.twig`.

### 2. Intégration et Correction Effet Zoom Image (Drift Zoom)

* **Contexte :** Le template HTML (copié d'un thème externe) utilisait une classe `drift-zoom` pour un effet de loupe au survol de l'image produit principale, mais cet effet ne fonctionnait pas correctement (l'image disparaissait au survol).
* **Intégration de la Librairie :**
    * Identification de la librairie JavaScript `Drift Zoom`.
    * Copie des fichiers nécessaires (`Drift.min.js`, `drift-basic.min.css`, `Drift.min.js.map`) depuis le thème original vers le dossier `assets/libs/drift-zoom/` du projet.
    * Import du fichier CSS `drift-basic.min.css` dans `assets/styles/app.css` via `@import`.
    * Import du fichier JavaScript `Drift.min.js` dans `assets/app.js` via `import`.
    * Ajout du **code d'initialisation JavaScript** nécessaire (ex: `new Drift(...)`) dans `assets/app.js` pour activer la librairie sur les éléments concernés.
* **Correction de la Source du Zoom :**
    * Identification que l'attribut `data-zoom` sur la balise `<img>` pointait vers un chemin d'image invalide (`assets/...`).
    * Correction de l'attribut pour utiliser également la fonction `asset()` et pointer vers une URL d'image valide : `data-zoom="{{ asset('images/' ~ article.image) }}"`.
* **Résultat :** L'effet de zoom au survol est maintenant fonctionnel sur la page détail produit.

### 3. Clarifications Conceptuelles (Apprentissage)

* Revue et approfondissement de concepts Symfony clés : cycle requête/réponse, objet `Request` vs requête brute HTTP, rôle des Services, des Repositories et du Modèle (MVC), Injection de Dépendances et Conteneur de Services, fonctionnement de la fonction `asset()` vs dossier `assets/`, filtres Twig (`default`), opérateurs Twig (`~`).
* Discussion sur les bonnes pratiques Git (commit avant modification, branches).
* Analyse des outils de développement du navigateur (onglet Réseau, Inspecteur d'éléments).
* Distinction entre classes Bootstrap natives et classes CSS/JS personnalisées issues de thèmes.
* Fonctionnement du système d'assets de Symfony (AssetMapper) et des imports JS/CSS.

---
### 1. Correction Affichage Images & Favicons (Utilisation de `asset()`)

* **Problème Identifié :** Les images des articles et les favicons ne s'affichaient pas de manière cohérente sur toutes les pages (ex: OK sur `/categorie?id=X`, mais KO sur `/produit/X`).
* **Cause :** Utilisation de chemins relatifs (ex: `src="images/..."`, `href="assets/img/..."`) dans les templates Twig. Le navigateur interprétait ces chemins différemment en fonction de l'URL de la page courante.
* **Solution Implémentée :** Remplacement systématique par la fonction Twig `asset()` pour générer des URLs publiques fiables depuis la racine web (`public/`).
    * Pour les images articles (supposées dans `public/images/`) : `src="{{ asset('images/' ~ article.image) }}"`.
    * Pour les favicons (situés dans `public/assets/img/`) : `href="{{ asset('assets/img/favicon.png') }}"`.
    * Cette correction a été appliquée dans `detail_produit.html.twig`, `categorie.html.twig` et `base.html.twig`.

### 2. Intégration et Correction Effet Zoom Image (Drift Zoom)

* **Contexte :** Le template HTML (copié d'un thème externe) utilisait une classe `drift-zoom` pour un effet de loupe au survol, mais l'effet échouait (image disparaissait).
* **Intégration de la Librairie :**
    * Copie des fichiers `Drift.min.js` et `drift-basic.min.css` (et `.map`) depuis le thème original vers le dossier `assets/libs/drift-zoom/` du projet.
    * Import du CSS via `@import` dans `assets/styles/app.css`.
    * Import du JS via `import` dans `assets/app.js` (géré par AssetMapper).
    * Ajout du code d'initialisation JavaScript nécessaire (`new Drift(...)` ou similaire) dans `assets/app.js`.
* **Correction de la Source du Zoom (`data-zoom`) :**
    * Identification que l'attribut `data-zoom` sur la balise `<img>` pointait vers un chemin d'image invalide.
    * Correction de l'attribut pour utiliser `asset()` et pointer vers l'URL de l'image principale : `data-zoom="{{ asset('images/' ~ article.image) }}"` (en supposant images produits dans `public/images/`).
* **Résultat :** L'effet de zoom au survol est fonctionnel.

### 3. Clarifications Conceptuelles (Apprentissage)

* Revue et approfondissement de concepts Symfony/Twig/HTTP/Git : cycle requête/réponse, objet `Request` vs requête brute HTTP, rôle des Services, des Repositories et du Modèle (MVC), **distinction claire entre Injection de Dépendances pour les Services (ex: `PostRepository` dans `actu()`) et ParamConverter pour les Entités liées à un paramètre de route (ex: `Post` dans `detail()`**) , fonctionnement de la fonction `asset()` vs dossier `assets/`, filtres Twig (`default`), opérateurs Twig (`~`).
* Discussion sur les bonnes pratiques Git (commit avant modification, branches).
* Analyse des outils de développement du navigateur (onglet Réseau, Inspecteur d'éléments).
* Distinction entre classes Bootstrap natives et classes CSS/JS personnalisées issues de thèmes.
* Fonctionnement du système d'assets de Symfony (AssetMapper) et des imports JS/CSS.

### 4. Mise en Place Structure Blog/Actualités (Pattern Liste -> Détail)

* **Contexte :** Initialisation de la section "Actualités" du site (basée sur l'entité `Post`).
* **Structure Implémentée (par le mentor, à compléter/styliser par l'apprenti) :**
    * **Route Liste (`/actualites`) :** Gérée par `PostController::actu(PostRepository $postRepository)`. Utilise l'**Injection de Dépendances (DI)** standard pour obtenir le `PostRepository` afin de récupérer la liste des posts. Rend le template `postindex.html.twig` en passant la liste (`posts`).
    * **Route Détail (`/actualites/{id}`) :** Gérée par `PostController::detail(Post $post)`. Utilise le **ParamConverter** pour obtenir directement l'entité `Post` correspondant à l'`id` de l'URL et la passe au template `detail.html.twig`. La gestion du 404 (si l'ID n'existe pas) est automatique.
    * **Templates Twig :** `postindex.html.twig` (liste avec boucle `for` et lien `path('app_actu_detail', {id: post.id})`) et `detail.html.twig` (détail recevant la variable `post`).
* **Objectif Pédagogique :** Pratiquer et comprendre le pattern Liste->Détail, le routage avec paramètres, et la différence entre l'injection d'un service (Repository via DI) et l'injection d'une entité via l'URL (ParamConverter).
---
## 📰 Section Actualités / Blog (Frontend)

Mise en place des vues pour afficher les posts gérés en administration.

* **Page Liste (`/actualites`) :**
    * **Route :** `app_actu`, gérée par `PostController::actu()`.
    * **Données :** Récupération de la liste des `Post` via `PostRepository`, triés par date.
    * **Template :** `postindex.html.twig`.
    * **Affichage :** Utilise une boucle `{% for post in posts %}` pour afficher chaque post dans une structure adaptée d'un thème Bootstrap (probablement dans la colonne centrale). Affiche dynamiquement :
        * Image principale (`post.image` via `asset()` et classe `img-fluid`).
        * Titre (`post.title`) - rendu cliquable vers le détail.
        * Extrait du contenu (`post.content` filtré avec `striptags|slice`).
        * Date de création (`post.createdAt` formatée avec `date`).
        * Bouton "Détail du blog" (actuellement avec `href="#"`, à côté du titre).
    * Les colonnes latérales et la section "Recent Posts" du thème restent statiques pour l'instant.

* **Page Détail (`/actualites/{id}`) :**
    * **Route :** `app_actu_detail`, gérée par `PostController::detail()`.
    * **Données :** Utilisation du **ParamConverter** de Symfony : l'objet `Post` correspondant à l'`{id}` de l'URL est automatiquement récupéré et injecté dans le contrôleur (`Post $post`). Gestion automatique des 404 si l'ID est inconnu.
    * **Template :** `detail.html.twig`.
    * **Affichage :** Affiche les informations de base du `$post` reçu (titre, contenu brut). *(Note : Ce template peut être enrichi pour afficher aussi l'image, la date formatée, etc.)*

* **Principes Appliqués :** Illustration du pattern Liste->Détail, utilisation de l'Injection de Dépendances (pour le Repository) et du ParamConverter (pour l'Entité), génération d'URL dynamiques avec `path()`, utilisation de `asset()` pour les ressources, formatage Twig (filtres `date`, `slice`, `striptags`, `raw`).

---
---

## 📧 Formulaire de Contact

Mise en place d'un formulaire de contact fonctionnel permettant aux utilisateurs d'envoyer des messages.

- **Contrôleur dédié (`ContactController`) :** Gère l'affichage et le traitement du formulaire.
- **Type de Formulaire (`ContactFormType`) :**
    - Définit les champs : Nom (`TextType`), Email (`EmailType`), Sujet (`TextType`), Message (`TextareaType`).
    - Intègre la validation côté serveur avec le composant **Validator** de Symfony :
        - `NotBlank` pour tous les champs.
        - `Email` pour le champ email.
    - Configuration des labels, placeholders et attributs HTML.
- **Intégration Twig :**
    - Utilisation des fonctions `form_start()`, `form_row()`, `form_end()` dans le template (`templates/home/contact.html.twig`).
    - Application du thème **Bootstrap 5** pour les formulaires (`bootstrap_5_layout.html.twig` via `twig.yaml`) pour une intégration visuelle cohérente.
- **Traitement de la Soumission :**
    - Utilisation de `$form->handleRequest($request)`.
    - Vérification de la soumission et de la validité avec `$form->isSubmitted()` et `$form->isValid()`.
    - **Affichage des erreurs de validation** directement au niveau des champs grâce au thème de formulaire.
    - Implémentation du pattern **Post/Redirect/Get (PRG)** avec `redirectToRoute()` après une soumission valide.
    - **Affichage de messages flash de succès** (`$this->addFlash('success', ...)` lu via `app.flashes` dans `base.html.twig`) après redirection.
- **Résolution de Problèmes :**
    - Identification et correction d'un conflit avec un script JavaScript du thème (`validate.js`) qui empêchait la soumission standard du formulaire Symfony.
    - Correction du chemin du template utilisé dans le contrôleur.
    - Débogage de l'affichage des erreurs et des messages flash.

*(Note : La logique d'envoi d'email sera implémentée à l'étape suivante).*
 **Traitement de la Soumission et Envoi d'Email :**
    - Utilisation de `$form->handleRequest($request)`, `$form->isSubmitted()` et `$form->isValid()`.
    - Affichage des erreurs de validation au niveau des champs.
    - **Utilisation du composant Symfony Mailer** pour la construction et l'envoi des emails.
    - Configuration du `MAILER_DSN` dans le fichier `.env` pour se connecter au service SMTP de **Brevo**.
    - Construction d'un objet `Symfony\Component\Mime\Email` avec les données du formulaire (`from`, `to`, `subject`, `text`, `html`).
        - *(Note : L'en-tête `Reply-To` a été initialement envisagé puis retiré sur conseil du mentor pour optimiser la délivrabilité avec Brevo).*
    - Envoi de l'email via le service `$mailer->send($email)` à l'intérieur d'un bloc `try...catch (TransportExceptionInterface $e)` pour une gestion robuste des erreurs d'envoi.
    - Implémentation du pattern **Post/Redirect/Get (PRG)** avec `redirectToRoute()` et `Response::HTTP_SEE_OTHER`.
    - Affichage de messages flash de succès ou d'erreur (`app.flashes` dans `base.html.twig`).
- **Résolution de Problèmes et Configuration :**
    - Identification et résolution d'un conflit avec un script JavaScript du thème qui empêchait la soumission standard.
    - Débogage et configuration du `MAILER_DSN` pour Brevo.
    - Clarification des concepts d'envoi d'email synchrone (utilisé ici) vs. asynchrone (via Symfony Messenger, qui a été désactivé pour l'envoi des emails de contact pour simplifier).

---
---

## ✨ Améliorations et Corrections Récentes (Suite)

### Session du 8 Mai - Montpellier (Soir)

* **Implémentation du Formulaire de Contact :**
    * Création de `ContactController` et `ContactFormType`.
    * Définition des champs (Nom, Email, Sujet, Message) avec types Symfony (`TextType`, `EmailType`, `TextareaType`).
    * Mise en place de la validation côté serveur avec les contraintes `NotBlank` et `Email`.
    * Intégration du formulaire dans le template Twig `home/contact.html.twig` en utilisant les fonctions `form_start`, `form_row`, `form_end` et le thème Bootstrap 5.
    * **Débogage pas-à-pas :**
        * Correction du chemin du template dans la méthode `render()` du contrôleur.
        * Identification et résolution d'un conflit avec un script JavaScript du thème (`validate.js`) qui empêchait la méthode `$form->isSubmitted()` de fonctionner correctement (résolu en commentant le script fautif).
        * Vérification de la génération et de l'affichage des erreurs de validation au niveau des champs.
        * Mise en place de l'affichage des messages flash (`app.flashes` dans `base.html.twig`) pour le feedback utilisateur après soumission réussie.
    * Validation du cycle complet : Affichage -> Soumission invalide (affichage erreurs) -> Soumission valide -> Redirection (PRG) -> Affichage message flash succès.
* **Clarifications Conceptuelles (Suite) :** Fonctionnement de `dd()`, mécanisme des sessions et des messages flash, validation HTML5 vs validation Symfony, rôle du thème de formulaire Twig.
* **Prochaine étape :** Configuration de Mailer (via `MAILER_DSN`) et implémentation de l'envoi d'email dans `ContactController`.

---
## ✨ Améliorations et Corrections Récentes (Suite)

### Session du [Date de finalisation avec mentor, ex: 10 ou 11 Mai] - Montpellier

* **Finalisation du Formulaire de Contact avec Envoi d'Email via Brevo :**
    * Configuration réussie du `MAILER_DSN` dans le fichier `.env` pour utiliser le service SMTP de Brevo.
    * Implémentation de la logique d'envoi d'email dans `ContactController.php` en utilisant le composant Symfony Mailer.
        * Construction de l'objet `Email` avec les données du formulaire.
        * Utilisation de `try...catch (TransportExceptionInterface $e)` pour gérer les erreurs d'envoi.
        * Affichage de messages flash de succès ou d'erreur spécifiques à l'envoi.
    * Tests et validation de l'envoi effectif des emails via Brevo.
    * Discussion et application des conseils du mentor concernant la configuration de l'envoi (par exemple, la non-utilisation de `SendEmailMessage: async` de Messenger pour ce formulaire, et la gestion de l'en-tête `Reply-To` pour la délivrabilité).
* **Revue et consolidation des acquis** sur le fonctionnement des formulaires Symfony, de la validation, des messages flash, et du composant Mailer.

---

## 💬 Système de Commentaires (Fondations)

Mise en place de la structure de base (entité) pour la future fonctionnalité de commentaires.

* **Création de l'entité `Comment`** (`src/Entity/Comment.php`) et de son `CommentRepository` (`src/Repository/CommentRepository.php`).
    L'entité `Comment` possède les propriétés suivantes :
    * `id`: Identifiant unique auto-incrémenté (clé primaire).
    * `content` (type `text`): Le contenu textuel du commentaire. Ne peut pas être nul.
    * `createdAt` (type `datetime_immutable`): La date et l'heure de création du commentaire. Se remplit automatiquement à la création et ne peut pas être nul.
    * `isApproved` (type `boolean`): Indique si le commentaire a été approuvé par un administrateur (`true` pour approuvé, `false` pour non approuvé). Ne peut pas être nul.
    * `author` (Relation `ManyToOne` vers `User`): Lie le commentaire à l'utilisateur qui l'a écrit. Un commentaire doit toujours avoir un auteur.
        * L'entité `User` (`src/Entity/User.php`) a été mise à jour pour inclure une propriété `comments` (relation `OneToMany` inverse), permettant d'accéder à tous les commentaires d'un utilisateur.
    * `article` (Relation `ManyToOne` vers `Article`): Lie le commentaire à l'article spécifique concerné. Un commentaire doit toujours être lié à un article.
        * L'entité `Article` (`src/Entity/Article.php`) a été mise à jour pour inclure une propriété `comments` (relation `OneToMany` inverse), permettant d'accéder à tous les commentaires d'un article.

*Prochaine étape : Création de la migration Doctrine pour générer la table `comment` (et les relations) dans la base de données.*

-----

## 💬 Système de Commentaires

Implémentation de la fonctionnalité permettant aux utilisateurs connectés de soumettre des commentaires sur les articles de blog (entité `Post`).

1.  **Corrections et Améliorations des Entités :**
    * **`Comment.php`** :
        * La relation qui liait un `Comment` à une entité `Article` (produit de boutique) a été corrigée pour lier le `Comment` à une entité `Post` (article de blog). La propriété s'appelle maintenant `$post` et pointe vers `Post::class`.
        * Les méthodes `getArticle()`/`setArticle()` ont été renommées en `getPost()`/`setPost()`.
    * **`Article.php`** :
        * La relation inverse `OneToMany` (collection `$comments`) qui liait `Article` à `Comment` a été supprimée, car les commentaires ne concernent plus les `Article`s.
    * **`Post.php`** :
        * Une nouvelle relation inverse `OneToMany` (propriété `$comments`) a été ajoutée pour lier un `Post` à sa collection de `Comment`s.
        * Le constructeur et les méthodes `getComments()`, `addComment()`, `removeComment()` ont été ajoutés/mis à jour en conséquence.
    * De nouvelles **migrations Doctrine** ont été générées et appliquées pour refléter ces changements dans la structure de la base de données (par exemple, la table `comment` utilise maintenant une colonne `post_id`).

2.  **Création du Formulaire de Commentaire (`CommentFormType.php`) :**
    * Un nouveau type de formulaire `src/Form/CommentFormType.php` a été créé.
    * Il est lié à l'entité `Comment` (`data_class => Comment::class`).
    * Il définit les champs visibles par l'utilisateur pour la soumission :
        * `content` (de type `TextareaType`) pour le texte du commentaire.
        * Un bouton `submit` ("Publier le commentaire").
    * Les autres propriétés de `Comment` (comme `author`, `post`, `createdAt`, `isApproved`) sont gérées dans le contrôleur.

3.  **Logique dans le Contrôleur (`PostController.php`) :**
    * La méthode `detail(Post $post, Request $request, EntityManagerInterface $entityManager)` a été modifiée pour gérer l'affichage et la soumission du formulaire de commentaire.
    * **Affichage :**
        * Un nouvel objet `Comment` est créé.
        * Une instance de `CommentFormType` est créée et liée à cet objet `Comment`.
        * La vue du formulaire (`comment_form`) est passée au template Twig.
    * **Soumission (`if ($form->isSubmitted() && $form->isValid())`) :**
        * L'utilisateur connecté est récupéré (`$this->getUser()`) et défini comme `author` du commentaire. (Une vérification basique est en place pour s'assurer que l'utilisateur est connecté).
        * Le `$post` actuel de la page est défini comme `post` du commentaire.
        * `createdAt` est initialisé avec la date/heure actuelle.
        * `isApproved` est mis à `true` par défaut (pour un affichage direct dans un premier temps).
        * Le nouveau commentaire est sauvegardé en base de données via l'`EntityManager` (`persist` et `flush`).
        * Un message flash de succès est affiché.
        * L'utilisateur est redirigé vers la même page de détail du post.

4.  **Intégration dans le Template Twig (`post/detail.html.twig`) :**
    * Le formulaire de commentaire est affiché en utilisant `{{ form(comment_form) }}`.
    * L'affichage du formulaire est conditionné par la connexion de l'utilisateur (`{% if app.user %}`). Un message guide les utilisateurs non connectés vers la page de connexion.

*Prochaine étape : Afficher les commentaires existants sous chaque post.*

---
## 💬 Système de Commentaires

Implémentation de la fonctionnalité permettant aux utilisateurs connectés de soumettre et de visualiser des commentaires sur les articles de blog (entité `Post`).

1.  **Corrections et Améliorations des Entités :**
    * **`Comment.php`** : La relation a été corrigée pour lier le `Comment` à une entité `Post` (propriété `$post`).
    * **`Article.php`** : La relation incorrecte vers `Comment` a été supprimée.
    * **`Post.php`** : Une relation inverse `OneToMany` (propriété `$comments`) a été ajoutée pour lier un `Post` à sa collection de `Comment`s.
    * Des **migrations Doctrine** ont été appliquées pour refléter ces changements en base de données.

2.  **Création du Formulaire de Commentaire (`CommentFormType.php`) :**
    * Le formulaire `src/Form/CommentFormType.php` (lié à l'entité `Comment`) définit les champs pour la soumission : `content` (`TextareaType`) et un bouton `submit`.

3.  **Logique dans le Contrôleur (`PostController.php`) pour la soumission :**
    * La méthode `detail()` gère la création et la soumission du `CommentFormType`.
    * Lors d'une soumission valide, le `Comment` est peuplé (`author`, `post`, `createdAt`, `isApproved` à `true` par défaut) et sauvegardé en base de données.
    * L'utilisateur est redirigé avec un message flash de succès.

4.  **Intégration du Formulaire dans le Template (`post/detail.html.twig`) :**
    * Le formulaire est affiché via `{{ form(comment_form) }}`, conditionné par la connexion de l'utilisateur.

5.  **Affichage des Commentaires Existants :** *(Nouvelle partie)*
    * **`PostController.php` (méthode `detail()`) :**
        * Récupère la collection des commentaires associés au post actuel via `$post->getComments()`.
        * Passe cette collection (variable `comments`) au template Twig `post/detail.html.twig`.
    * **`templates/post/detail.html.twig` :**
        * Le nombre de commentaires est affiché dynamiquement (`{{ comments|length }}`).
        * Une boucle `{% for comment_item in comments %}` parcourt la collection.
        * Pour chaque `comment_item`, les informations suivantes sont affichées :
            * Avatar (placeholder dynamique basé sur l'email de l'auteur).
            * Nom de l'auteur (`comment_item.author.userIdentifier`).
            * Date de création (`comment_item.createdAt|date(...)`).
            * Contenu du commentaire (`comment_item.content|nl2br`).
        * Un message s'affiche s'il n'y a aucun commentaire.
        * La structure HTML existante pour un commentaire individuel a été adaptée pour utiliser ces variables dynamiques.

*Prochaine étape : Mise en place de la modération des commentaires par l'administrateur.*

## 💬 Système de Commentaires

Implémentation de la fonctionnalité permettant aux utilisateurs connectés de soumettre des commentaires sur les articles de blog (entité `Post`) et d'afficher les commentaires approuvés.

1.  **Entités et Relations :**
    * `Comment.php` est lié à `Post.php` (propriété `$post`).
    * `Post.php` a une collection `$comments` pour la relation inverse.
    * La base de données a été mise à jour via les migrations.

2.  **Formulaire de Commentaire (`CommentFormType.php`) :**
    * Définit les champs `content` (`TextareaType`) et un bouton `submit`.
    * Lié à l'entité `Comment`.

3.  **Logique dans le Contrôleur (`PostController.php`) pour la soumission :**
    * La méthode `detail()` gère la création et la soumission du `CommentFormType`.
    * Lors d'une soumission valide par un utilisateur connecté :
        * Le `Comment` est peuplé (`author`, `post`, `createdAt`).
        * **`isApproved` est maintenant mis à `false` par défaut.** Le commentaire est en attente de modération.
        * Le commentaire est sauvegardé en base de données.
        * Un message flash ("...en attente d'approbation.") est affiché.
        * L'utilisateur est redirigé vers la page du post.

4.  **Intégration du Formulaire dans `templates/post/detail.html.twig` :**
    * Le formulaire est affiché via `{{ form(comment_form) }}` pour les utilisateurs connectés.

5.  **Affichage des Commentaires Approuvés :**
    * **`PostController.php` (méthode `detail()`) :**
        * Récupère tous les commentaires du post (`$post->getComments()`).
        * **Filtre cette collection en PHP pour ne garder que les commentaires où `isApproved` est `true`** (`$allComments->filter(...)`).
        * Passe cette liste filtrée (`$approvedComments`) au template Twig.
    * **`templates/post/detail.html.twig` :**
        * Affiche dynamiquement le nombre de commentaires approuvés.
        * Boucle sur la collection des commentaires approuvés pour afficher le contenu, l'auteur, la date de chaque commentaire.
        * Les nouveaux commentaires (non approuvés) n'apparaissent donc pas immédiatement.

*Prochaine étape : Mise en place de l'interface d'administration (EasyAdmin) pour la modération des commentaires (approbation, modification, suppression).*
## 💬 Système de Commentaires

Implémentation d'un système complet de commentaires pour les articles de blog (`Post`), incluant la soumission par les utilisateurs, l'affichage et la modération par l'administrateur.

1.  **Entités et Relations :**
    * `Comment.php` est lié à `Post.php` (propriété `$post`) et à `User.php` (propriété `$author`).
    * `Post.php` et `User.php` ont les relations inverses (`OneToMany` vers `Comment`).
    * Les entités `User` et `Post` ont été dotées d'une méthode `__toString()` pour un meilleur affichage dans les formulaires et listes d'association.
    * La base de données a été mise à jour via les migrations.

2.  **Formulaire de Soumission (`CommentFormType.php`) :**
    * Définit les champs `content` (`TextareaType`) et un bouton `submit`.
    * Lié à l'entité `Comment`.

3.  **Logique dans `PostController.php` (méthode `detail()`) :**
    * **Soumission :** Gère la création du `CommentFormType`. Lors d'une soumission valide par un utilisateur connecté, le `Comment` est peuplé (`author`, `post`, `createdAt`), `isApproved` est mis à `false` par défaut, et le commentaire est sauvegardé. Un message flash ("...en attente d'approbation.") est affiché.
    * **Affichage :** Récupère les commentaires du post, les filtre en PHP pour ne garder que ceux où `isApproved` est `true`, et les passe au template.

4.  **Intégration dans `templates/post/detail.html.twig` :**
    * Le formulaire de soumission est affiché pour les utilisateurs connectés.
    * Les commentaires approuvés sont listés dynamiquement, affichant l'auteur, la date et le contenu.

5.  **Modération des Commentaires via EasyAdmin :** *(Nouvelle partie)*
    * L'extension PHP `intl` a été activée (via `php.ini` et redémarrage d'Apache) car elle est requise par EasyAdmin pour les champs de date/heure.
    * Un `CommentCrudController.php` a été généré dans `src/Controller/Admin/`.
    * Un lien "Gestion des commentaires" a été ajouté au menu du `DashboardController.php`.
    * **Configuration de `CommentCrudController.php` (`configureFields`) :**
        * Affiche les champs : `id` (caché sur les formulaires), `content` (`TextareaField`), `author` (`AssociationField`), `post` (`AssociationField`), `createdAt` (`DateTimeField`), et `isApproved` (`BooleanField`).
        * Les champs `author` et `post` sont configurés avec `hideOnForm()` dans le formulaire d'édition pour empêcher leur modification accidentelle, car ils sont définis à la création du commentaire.
    * **Fonctionnalités de modération :**
        * La liste des commentaires s'affiche dans EasyAdmin.
        * Le statut "Approuvé ?" (`isApproved`) peut être basculé directement depuis la liste grâce à l'interrupteur du `BooleanField`.
        * L'édition du contenu d'un commentaire est possible.
        * La suppression de commentaires est fonctionnelle.
        * Les commentaires approuvés via EasyAdmin apparaissent ensuite correctement sur la page publique du blog.

*Prochaines étapes possibles pour les commentaires : Améliorations de l'interface d'administration (tri, filtres, actions personnalisées), affinage de l'affichage utilisateur (nom d'auteur, avatars), fonctionnalités avancées (réponses, likes).*

---
## 🛒 Panier d'Achat (Basé sur la Session)

Mise en place des fonctionnalités de base pour le panier d'achat utilisant la session PHP.

1.  **Logique du Contrôleur (`CartController.php`) :**
    * **Ajout au panier :** Méthode `addToCart(int $productId, Request $request)` avec la route `/panier/ajouter/{id}`.
        * Récupère/initialise le panier en session (tableau `[product_id => quantity]`).
        * Ajoute ou incrémente la quantité du produit.
        * Sauvegarde le panier en session.
        * Affiche un message flash de succès et redirige (vers la page précédente ou l'accueil).
    * **Affichage du Panier :** Méthode `panier(Request $request, ArticleRepository $articleRepository)` avec la route `/panier`.
        * Récupère le panier brut de la session.
        * Pour chaque produit, récupère les détails complets de l'entité `Article` via `ArticleRepository`.
        * Construit un tableau `$detailedCart` avec les objets `Article`, les quantités et les totaux par ligne.
        * Calcule le montant total du panier `$totalCartAmount`.
        * Passe ces données au template `templates/home/panier.html.twig`.
    * **Suppression d'un article :** Méthode `removeFromCart(int $productId, Request $request)` avec la route `/panier/supprimer/{id}`.
        * Supprime l'article spécifié du panier en session.
        * Affiche un message flash et redirige vers la page du panier.
    * **Vider le panier :** Méthode `clearCart(Request $request)` avec la route `/panier/vider`.
        * Supprime l'intégralité du panier de la session.
        * Affiche un message flash et redirige vers la page du panier.
    * **Icône de Panier Dynamique (Navbar) :** *(Nouvelle partie)*
        * Une méthode publique `cartIcon(Request $request)` a été ajoutée à `CartController.php`. Elle n'a pas de route URL directe.
        * Elle calcule le nombre total d'unités de produits dans le panier en session.
        * Elle rend un template partiel `templates/cart/_cart_icon.html.twig` en lui passant ce nombre (`item_count`).

2.  **Templates Twig :**
    * **`templates/home/panier.html.twig` :**
        * Affiche le titre "Votre Panier".
        * Boucle sur `detailed_cart_items` pour afficher chaque produit (image, titre, prix unitaire, quantité, total par ligne).
        * Affiche le `total_cart_amount`.
        * Contient des liens (maintenant fonctionnels) pour supprimer un article et vider le panier.
        * Affiche un message si le panier est vide.
    * **`templates/article/detail_produit.html.twig` (ou équivalent) :** *(Ou la page catégorie selon où il l'a mis)*
        * Contient un lien/bouton "Ajouter au panier" qui pointe vers la route `app_add_cart` en passant l'`article.id`.
    * **`templates/cart/_cart_icon.html.twig` :** *(Nouveau fichier)*
        * Template partiel contenant le HTML pour l'icône du panier et l'affichage de `item_count` (souvent dans un badge), avec un lien vers la page panier.
    * **`templates/base.html.twig` (ou partiel de la barre de navigation) :** *(Modification)*
        * L'icône de panier statique a été remplacée par un appel à `{{ render(controller('App\\Controller\\CartController::cartIcon')) }}` pour afficher dynamiquement l'icône et le nombre d'articles.

*Prochaine étape pour le panier : Permettre la modification des quantités des articles directement depuis la page panier.*

---

## 🛒 Panier d'Achat (Basé sur la Session)

Mise en place des fonctionnalités de base pour le panier d'achat utilisant la session PHP, incluant l'ajout, la visualisation détaillée, la suppression d'articles, le vidage du panier, la mise à jour des quantités et un indicateur dynamique dans la barre de navigation.

1.  **Logique du Contrôleur (`CartController.php`) :**
    * **Ajout au panier :** Méthode `addToCart(int $productId, Request $request)` (route `/panier/ajouter/{id}`). Gère l'ajout ou l'incrémentation de quantité d'un produit en session.
    * **Affichage du Panier :** Méthode `panier(Request $request, ArticleRepository $articleRepository)` (route `/panier`). Prépare les données détaillées des articles du panier (objets `Article`, quantités, totaux par ligne) et le montant total pour l'affichage dans `templates/home/panier.html.twig`.
    * **Suppression d'un article :** Méthode `removeFromCart(int $productId, Request $request)` (route `/panier/supprimer/{id}`). Supprime un article spécifique du panier en session.
    * **Vider le panier :** Méthode `clearCart(Request $request)` (route `/panier/vider`). Vide intégralement le panier en session.
    * **Mise à jour des Quantités :** *(Nouvelle partie)* Méthode `updateQuantities(Request $request)` (route `/panier/mettre-a-jour`, méthode `POST`).
        * Récupère les nouvelles quantités soumises par le formulaire de la page panier (tableau `quantities[product_id => new_quantity]`).
        * Met à jour les quantités dans le panier en session. Si une quantité est mise à 0 ou moins, l'article est retiré du panier.
        * Affiche un message flash de succès et redirige vers la page du panier.
    * **Icône de Panier Dynamique (Navbar) :** Méthode `cartIcon(Request $request)` (appelée via `render(controller(...))`). Calcule le nombre total d'unités de produits dans le panier et rend le template partiel `_cart_icon.html.twig`.

2.  **Templates Twig :**
    * **`templates/home/panier.html.twig` :**
        * Affiche la liste détaillée des produits du panier (image, titre, prix, quantité, total par ligne) et le montant total.
        * Contient maintenant un **formulaire (`<form method="post">`)** qui entoure la liste des articles.
        * Pour chaque article, la quantité est affichée dans un champ **`<input type="number" name="quantities[article_id]">`**, permettant à l'utilisateur de la modifier.
        * Un bouton **"Mettre à jour le panier" (`type="submit"`)** soumet les nouvelles quantités à l'action `updateQuantities`.
        * Contient des liens fonctionnels pour supprimer un article individuel (`app_cart_remove`) et vider le panier (`app_cart_clear`).
        * Affiche un message si le panier est vide.
    * **`templates/home/detail_produit.html.twig`** (ou équivalent pour la page de détail d'un article) :
        * Contient un lien/bouton "Ajouter au panier" pointant vers la route `app_add_cart`.
    * **`templates/cart/_cart_icon.html.twig` :**
        * Template partiel affichant l'icône du panier et le nombre d'articles (`item_count`), avec un lien vers la page panier.
    * **`templates/base.html.twig`** (ou partiel de la barre de navigation) :
        * Intègre l'icône de panier dynamique via `{{ render(controller('App\\Controller\\CartController::cartIcon')) }}`.

*Prochaine étape pour le panier : Début du processus de commande (Checkout) ou améliorations UX (JavaScript pour les quantités, etc.).*

## 🛒 Panier d'Achat et Début du Processus de Commande

Mise en place des fonctionnalités du panier et de la première étape du processus de commande.

1.  **Panier d'Achat (Basé sur la Session) - Fonctionnalités Clés :**
    * **Logique Centralisée (`CartService.php`) :** Un service `CartService` a été créé pour gérer toute la logique métier du panier (récupération des données de session, calcul des détails des articles avec `ArticleRepository`, calcul des totaux).
    * **`CartController.php` :**
        * Utilise `CartService` pour les actions :
            * `addToCart()`: Ajout/incrémentation de produit.
            * `panier()`: Préparation des données pour l'affichage détaillé du panier.
            * `removeFromCart()`: Suppression d'un article.
            * `clearCart()`: Vidage complet du panier.
            * `updateQuantities()`: Mise à jour des quantités depuis la page panier.
        * Gère les messages flash et les redirections.
    * **`templates/home/panier.html.twig` :** Affiche le panier détaillé avec des formulaires pour la mise à jour des quantités et des liens pour les autres actions.
    * **Icône de Panier Dynamique (Navbar) :**
        * `CartController::cartIcon()` et `templates/cart/_cart_icon.html.twig` affichent dynamiquement le nombre d'articles dans la barre de navigation via `render(controller(...))`.

2.  **Début du Processus de Commande (`CheckoutController.php`) :** *(Nouvelle partie)*
    * **Contrôleur `CheckoutController.php` :**
        * Une méthode `index()` (ou `checkout()`) est accessible via la route `/checkout` (nommée `app_checkout` ou `app_checkout_start`).
        * Cette méthode utilise le `CartService` pour récupérer les données détaillées du panier (`checkout_items` et `checkout_total_amount`).
        * Elle vérifie si le panier est vide et redirige vers la page panier avec un message si c'est le cas.
        * Elle passe les données du panier au template de la page de commande.
    * **Template `templates/checkout/checkout.html.twig` :**
        * Le design statique de la page de commande a été intégré dans ce template Twig, en étendant `base.html.twig`.
        * La section **"Résumé de la commande"** (souvent dans une colonne latérale) a été rendue **dynamique** :
            * Affiche le nombre correct d'articles différents (`{{ checkout_items|length }}`).
            * Boucle sur `checkout_items` pour afficher les détails de chaque produit (image, titre, quantité, prix unitaire).
            * Affiche le sous-total et le total général du panier en utilisant `{{ checkout_total_amount }}`.
        * Le reste de la page (formulaires d'adresse, de paiement) est pour l'instant basé sur le HTML statique du thème.
        * La balise `<body>` redondante a été retirée du template.
    * **Lien depuis le panier :** Le bouton "Passer à la caisse" sur la page `panier.html.twig` redirige maintenant correctement vers la route `/checkout`.

*Prochaine étape pour le processus de commande : Mettre en place un formulaire Symfony pour la collecte des informations client et de l'adresse de livraison.*

## 🛒 Panier d'Achat et Processus de Commande (Simulation)

Mise en place des fonctionnalités du panier, de la collecte d'informations pour la commande, d'une page de confirmation, et d'une finalisation simulée de la commande.

1.  **Panier d'Achat (Basé sur la Session) - Fonctionnalités Clés :**
    * **Logique Centralisée (`CartService.php`) :** Gère la récupération des données de session, le calcul des détails des articles (avec `ArticleRepository`) et des totaux.
    * **`CartController.php` :** Gère les actions d'ajout, d'affichage détaillé du panier, de suppression d'article, de vidage complet, de mise à jour des quantités, et l'affichage de l'icône de panier dynamique dans la barre de navigation (via `cartIcon()` et `_cart_icon.html.twig`).
    * **Templates Panier :** `templates/home/panier.html.twig` pour l'affichage et la gestion, `templates/home/detail_produit.html.twig` pour le bouton "Ajouter au panier", et `templates/base.html.twig` pour l'icône dynamique.

2.  **Processus de Commande (`CheckoutController.php`) :**
    * **Étape 1 : Collecte des Informations Client et Adresse (`checkout()` méthode) :**
        * Accessible via la route `/checkout` (nom `app_checkout`), accepte `GET` et `POST`.
        * Utilise `CartService` pour récupérer les données du panier et vérifie si le panier est vide (redirige si c'est le cas).
        * Crée et gère un formulaire Symfony (`CheckoutType.php`, non mappé pour l'instant) pour les informations client (prénom, nom, email, téléphone) et l'adresse de livraison (adresse, appartement, ville, code postal, état, pays).
        * Si le formulaire est soumis et valide, les données (`$data`) sont stockées en session sous la clé `checkout_data`.
        * Un message flash de succès est affiché, et l'utilisateur est redirigé vers la page de confirmation (`app_checkout_confirm`).
    * **Étape 2 : Page de Confirmation (`confirmation()` méthode) :** *(Nouvelle partie)*
        * Accessible via la route `/checkout/confirmation` (nom `app_checkout_confirm`), méthode `GET`.
        * Récupère les `checkout_data` (informations client/adresse) de la session et les données du panier via `CartService`.
        * Redirige vers le panier si des informations cruciales sont manquantes.
        * Passe toutes ces données au template `templates/checkout/confirmation.html.twig`.
    * **Étape 3 : Finalisation Simulée de la Commande (`placeOrder()` méthode) :** *(Nouvelle partie)*
        * Accessible via la route `/checkout/placer-commande` (nom `app_checkout_place_order`).
        * Simule la finalisation de la commande :
            * Vide le panier en supprimant la clé `'cart'` de la session.
            * Efface les données de checkout (`'checkout_data'`) de la session.
            * Affiche un message flash de succès ("Merci ! Votre commande a été enregistrée...").
            * Redirige l'utilisateur vers la page d'accueil.

3.  **Templates Checkout (`templates/checkout/`) :**
    * **`checkout.html.twig` :** Intègre le design statique de la page de commande. Affiche dynamiquement le résumé de la commande (via `checkout_items` et `checkout_total_amount` fournis par `CartService` via le contrôleur) et le formulaire Symfony (`checkout_form`) pour les informations client et l'adresse.
    * **`confirmation.html.twig` :** *(Nouveau fichier/modification)* Intègre le design statique de la page de confirmation de commande. Affiche dynamiquement :
        * Les informations client et l'adresse de livraison (depuis `checkout_data` en session).
        * Le résumé des articles de la commande (depuis `checkout_items`).
        * Le montant total (depuis `checkout_total_amount`).
        * Contient un bouton "Confirmer ma commande (Simulation)" qui pointe vers la route `app_checkout_place_order`.

*Prochaine étape pour le processus de commande : Mise en place de la persistance des commandes en base de données (création des entités `Order` et `OrderItem`, enregistrement de la commande) et/ou gestion des adresses utilisateur, et/ou intégration d'un système de paiement (simulation ou réel).*

---

## 🛒 Panier d'Achat et Processus de Commande (avec Sauvegarde en Base de Données)

Système de panier fonctionnel et processus de commande simulé jusqu'à l'enregistrement en base de données et l'affichage d'une page de remerciement.

1.  **Panier d'Achat (Basé sur la Session) - Fonctionnalités Clés :**
    * **Logique Centralisée (`CartService.php`) :** Gère la récupération des données de session, le calcul des détails des articles (avec `ArticleRepository`) et des totaux.
    * **`CartController.php` :** Gère les actions d'ajout, d'affichage détaillé du panier (`/panier`), de suppression d'article, de vidage complet, de mise à jour des quantités.
    * **Icône de Panier Dynamique (Navbar) :** `CartController::cartIcon()` et `templates/cart/_cart_icon.html.twig` affichent dynamiquement le nombre d'articles.
    * **Templates Panier :** `templates/home/panier.html.twig` pour l'affichage et la gestion ; `templates/home/detail_produit.html.twig` pour le bouton "Ajouter au panier".

2.  **Entités pour la Commande :** *(Nouvelle partie)*
    * **`Order.php` :** Nouvelle entité créée pour stocker les informations générales de la commande (utilisateur lié, informations client et de livraison saisies dans le formulaire, montant total, statut, date de création).
        * Relation `ManyToOne` avec `User` (optionnelle).
        * Relation `OneToMany` avec `OrderItem`.
        * Propriété `createdAt` initialisée dans le constructeur.
    * **`OrderItem.php` :** Nouvelle entité créée pour stocker les détails de chaque produit dans une commande.
        * Relation `ManyToOne` avec `Order` (obligatoire).
        * Relation `ManyToOne` avec `Article` (nommée `productArticle`, optionnelle, pour conserver un lien vers le produit original et récupérer l'image).
        * Stockage du nom (`productName`), prix unitaire (`productPrice`), quantité (`quantity`), et total de la ligne (`lineTotal`) au moment de la commande.
    * **Migration de Base de Données :** Les tables `order` et `order_item` ont été créées et les relations configurées via `make:migration` et `doctrine:migrations:migrate`.

3.  **Processus de Commande (`CheckoutController.php`) :**
    * **Étape 1 : Formulaire d'Informations (`checkout()` méthode) :**
        * Route `/checkout` (nom `app_checkout`), accepte `GET` (pour afficher) et `POST` (pour soumettre).
        * Utilise `CartService` pour afficher un résumé de commande dynamique sur la page.
        * Affiche un formulaire Symfony (`CheckoutType.php` - non mappé) pour les informations client et l'adresse de livraison.
        * **Si le formulaire est soumis et valide :**
            * Les données du formulaire (`checkoutFormData`) sont récupérées.
            * Un nouvel objet `Order` est créé et peuplé avec les `checkoutFormData`, le `totalAmount` du panier, un statut initial (ex: "Nouvelle commande"), et l'utilisateur connecté (si existant).
            * Pour chaque article dans le panier (`cartData['items']`), un nouvel objet `OrderItem` est créé, peuplé (nom, prix, quantité, lien vers l'`Order`, et lien vers l'`Article` original via `setProductArticle`), et persisté.
            * L'objet `Order` est persisté.
            * L'`EntityManager` effectue un `flush()` pour sauvegarder la commande et ses lignes en base de données.
            * L'ID de la nouvelle commande (`$order->getId()`) est récupéré.
            * Le panier (`cart`) et les données de checkout (`checkout_data`) sont **supprimés de la session**.
            * Un message flash de succès (incluant l'ID de la commande) est ajouté.
            * L'utilisateur est **redirigé vers la page de remerciement** (`app_checkout_thank_you`), en passant l'`orderId`.
    * **Étape 2 : Page de Remerciement (`thankYouPage()` méthode) :**
        * Route `/commande/merci/{orderId}` (nom `app_checkout_thank_you`), méthode `GET`.
        * Récupère l'objet `Order` complet depuis la base de données en utilisant l'`orderId` passé en paramètre.
        * Gère le cas où la commande n'est pas trouvée.
        * Passe l'objet `Order` au template `templates/checkout/thank_you.html.twig` (ou `confirmation.html.twig` si réutilisé).

4.  **Templates Checkout (`templates/checkout/`) :**
    * **`checkout.html.twig` :** Affiche le formulaire d'adresse Symfony et le résumé dynamique du panier. Le bouton "Valider la commande" soumet le formulaire pour créer la commande en BDD.
    * **`thank_you.html.twig` (ou `confirmation.html.twig` adapté) :** *(Mise à jour/Création)*
        * Affiche un message de remerciement.
        * Affiche dynamiquement les détails de la commande qui vient d'être passée, en utilisant l'objet `Order` et sa collection `orderItems` (numéro de commande, date, informations client/livraison, résumé des articles, total).
        * *(Note : Le problème d'affichage de l'image produit sur cette page sera revu avec le professeur).*

*Prochaine étape envisagée : Gestion du compte utilisateur (Mon Profil, Historique des commandes) ou intégration d'un système de paiement (ex: Stripe).*

---
## ✨ Fonctionnalités Mises en Place

### Back-Office (Administration)
* **Administration Complète via EasyAdmin :** Interface d'administration pour la gestion complète (CRUD) des produits (Articles), catégories, posts, et la modération des commentaires.
* **Gestion des Utilisateurs et des Rôles :** Système de sécurité robuste avec `ROLE_USER` et `ROLE_ADMIN`. Les accès à la section `/admin` sont protégés.
* **Upload d'Images :** Gestion simple de l'upload d'images pour les entités (ex: Posts) directement depuis le back-office.

### Front-Office (Site Public)
* **Gestion de Produits et Catégories :** Affichage des produits par catégories, avec un système de catégories et sous-catégories dynamiques et imbriquées.
* **Barre de Recherche et Filtres :** Un formulaire de recherche permet de filtrer les articles par mot-clé, avec des options de tri (par date, par prix).
* **Pagination :** Toutes les listes longues (articles, etc.) sont paginées pour une navigation fluide et de meilleures performances.
* **Slugs SEO :** Génération automatique de "slugs" pour des URLs propres et optimisées pour les moteurs de recherche (ex: `/article/titre-de-mon-article`).
* **Système de Commentaires :** Les utilisateurs connectés peuvent commenter les articles de blog. Les commentaires sont soumis à une modération par l'administrateur dans le back-office avant d'être affichés.
* **Panier d'Achat Complet :**
    * Gestion du panier en **Session PHP**.
    * Ajout, suppression, vidage et **mise à jour des quantités**.
    * Icône de panier dynamique dans la barre de navigation se mettant à jour en temps réel.
* **Processus de Commande :**
    * Formulaire de saisie des informations de livraison.
    * **Sauvegarde de la commande** et de ses détails en base de données (entités `Order` et `OrderItem`).
    * Page de remerciement dynamique après la commande.
* **Service d'Emails Automatisé :**
    * **Formulaire de contact** fonctionnel avec validation et envoi d'email via un service externe (Brevo SMTP).
    * Gestion des messages de feedback utilisateur (messages flash de succès ou d'erreur).
* **Gestion des Images :** Affichage dynamique des images (produits, articles) et gestion des chemins avec la fonction `asset()`. Intégration de librairies JavaScript externes (ex: effet de zoom) via AssetMapper.
* **Pages d'Erreur Personnalisées :** Templates pour les erreurs 403, 404, et 500 pour une expérience utilisateur soignée en production.

---